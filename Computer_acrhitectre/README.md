## 목차
|day 1 | day 2 | day 3 | day 4| day 5 | day 6 |
|--- | --- | --- | --- | --- | --- |
|[필요성](#필요성)|[비트](#비트)| [컴파일과정](#컴파일과정)| [명령어 사이클](#명령어사이클) | [명령어 파이프라이닝](#명령어파이프라이닝) |[RAM](#ram) |
|[데이터](#데이터)|[워드](#워드)|  [ALU](#alu) | [인터럽트](#인터럽트) | [파이프라인 위험](#파이프라인위험) |[메모리 주소](#메모리주소)|
|[명령어](#명령어)|[이진법](#이진법)|[플래그](#플래그) | [코어](#코어) | [슈퍼스칼라](#슈퍼스칼라) |[메모리 보호](#메모리보호)|
|[프로그램](#프로그램)|[플래그](#플래그)| [제어장치](#제어장치) | [스레드](#스레드) | [명령어 집합구조](#명령어집합구조) |[캐시](#캐시)|
|[cpu](#cpu)|[십육진법](#십육진법)| [레지스터](#레지스터) | | |[참조 지역성](#참조지역성)|
|[메모리](#메모리)|[문자 집합](#문자집합)| || |[하드디스크](#하드디스크)|
|[보조기억장치](#보조기억장치)|[인코딩](#인코딩)| || |[플래시 메모리](#플래시메모리)|
|[입출력장치](#입출력장치)|[디코딩](#디코딩)| || ||
|[메인보드](#메인보드)|[아스키](#아스키)| || ||
|[시스템버스](#시스템버스)|[유니코드](#유니코드)| || ||
||[utf](#utf)||| ||
||[고급 언어](#고급언어)||| ||
||[저급 언어](#저급언어)||| ||
||[기계어](#기계어)||| ||
||[어셈블리어](#어셈블리어)||| ||
||[컴파일](#컴파일)||| ||
||[인터프리터](#인터프리터)||| ||
||[명령어](#명령어)||| ||
||[연산코드](#연산코드)||| ||
||[오퍼랜드](#오퍼랜드)||| ||
||[주소 지정 방식](#주소지정방식)||| ||


### 필요성
<details>
<summary></summary>

전공과목과 기업에서 요구하는 컴퓨터과학의 가장 근본적이고 기초적인 지식이다.
정확하게 이해한다면 설계,개발에서 효율, 성능, 비용부분에서 이득을 볼수있으며 문제발생시 근본적인 해결에 도움을 준다.

</details>

### 데이터
<details>
<summary></summary>

정적인 정보

</details>

### 명령어
<details>
<summary></summary>

컴퓨터를 실질적으로 움직이는 정보

</details>

### 프로그램
<details>
<summary></summary>

명령어들의 모음

</details>

### cpu
<details>
<summary></summary>

- 메모리에 저장된 값을 읽고, 해석, 실행하는 장치
- 내부에 ALU, 레지스터,제어장치
- ALU : 계산하는 장치
- 레지스터 : 임시 저장장치
- 제어장치 : 제어 신호를 발생시키고 명령어를 해석하는 장치

</details>

### 메모리
<details>
<summary></summary>

- 현재 실행되는 프로그램의 명령어와 데이터를 저장
- 주소개념이 있다
- 휘발성

</details>

### 보조기억장치
<details>
<summary></summary>

- 비휘발성
- 하드 디스크, ssd, cd등등

</details>

### 입출력장치
<details>
<summary></summary>

컴퓨터 외부에 연결되어 내부와 정보를 교환하는 장치

</details>

### 메인보드
<details>
<summary></summary>

- 컴퓨터 부품을 부착
- 내부에 버스 존재

</details>

### 시스템버스
<details>
<summary></summary>

- 주소버스 : 주소 통로
- 데이터 버스 : 명령어, 데이터 통로
- 제어버스 : 제어신호 통로

</details>

### 비트
<details>
<summary></summary>

- 0과 1을 표현하는 가장 작은 정보단위
- n 비트로 2^n개 정보 표현 가능
  
</details>

### 워드
<details>
<summary></summary>

- CPU가 한 번에 처리할 수 있는 정보의 크기 단위
  
</details>

### 이진법
<details>
<summary></summary>

- 0, 1로 수를 표현하는 방법
- 음수 표현법 : 2의 보수
  
</details>

### 플래그
<details>
<summary></summary>
ALU가 계산한 결과에 추가 정보
  
  - 부호 플래그 : 연산한 결과의 부호
  - 제로 플래그 : 0인지 여부
  - 캐리 플래그 : 올림수, 빌림수 발생여부
  - 오버플로우 플래그 : 오버플로우 발생여부
  - 인터럽트 플래그 : 인터럽트 가능여부
  - 슈퍼바이저 플래그 : 커널모드와 사용자모드 구분
</details>

### 십육진법
<details>
<summary></summary>

- 0-9, A-F를 사용해 수를 표현하는 방법
- 이진수 4자리씩 변환 용이
  
</details>

### 문자집합
<details>
<summary></summary>

- 컴퓨터가 이해할 수 있는 문자의 모음
  
</details>

### 인코딩
<details>
<summary></summary>

- 문자를 코드화 하는 과정
  
</details>

### 디코딩
<details>
<summary></summary>

- 코드를 문자화 하는 과정
  
</details>

### 아스키
<details>
<summary></summary>

- 초창기 문자 집합
- 7비트 + 1비트(오류 검출 패리티 비트)
- 다양한 문자 표현 불가능
  
</details>

### 유니코드
<details>
<summary></summary>

- 통일된 문자 집합
  
</details>

### utf
<details>
<summary></summary>

- 유니코드를 인코딩하는 방식 8,16,32.. 등
  
</details>

### 고급언어
<details>
<summary></summary>

- 일반적인 프로그래밍언어
- 개발자가 이해가 편하다.
  
</details>

### 저급언어
<details>
<summary></summary>

- 컴퓨터가 이해하기 편하다.
- 기계어, 어셈블리어가 있다.
  
</details>

### 기계어
<details>
<summary></summary>

- 0,1로 이루어진 명령어 모음
  
</details>

### 어셈블리어
<details>
<summary></summary>

- 기계어를 읽기 편한 형태로 변환한 언어
  
</details>

### 컴파일
<details>
<summary></summary>

- 소스코드를 컴파일러가 컴파일 하면 목적코드가 나온다.
  
</details>

### 인터프리터
<details>
<summary></summary>

- 인터프리터에 의해 소스코드를 한 줄씩 실행한다.
- 소스코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요없다.
  
</details>

### 명령어
<details>
<summary></summary>

- operation code 와 operand로 구성되어있다.
  
</details>

### 연산코드
<details>
<summary></summary>

- 명령어가 수행할 연산
  1) 데이터 전송 : MODE,STORE,LOAD(FETCH),PUSH,POP
  3) 산술/논리 연산 : 사칙연산, 증감, 논리, 참거짓
  4) 제어 흐름 변경 : JUMP, CONDITIONAL JUMP, HALT, CALL, RETURN
  5) 입출력 제어 : READ, WRITE, START IO, TEST IO
  
</details>

### 오퍼랜드
<details>
<summary></summary>

- 연산에 사용할 데이터 or 연산에 사용할 데이터가 저장된 위치
- 주소필드라고도 부른다.
  
</details>

### 주소지정방식
<details>
<summary></summary>

- 연상에 사용할 데이터가 지정된 위치(유효 주소)를 찾는법
    1) 즉지 주소 지정 방식 : 데이터를 오러랜드 필드에 직접명시
    2) 직접 주소 지정 방식 : 유효주소를 명시
    3) 간접 주소 지정 장식 : 유효주소의 주소를 명시
    4) 레지스터 주소 지정 방식 : 데이터가 저장된 레지스터 명시
    5) 레지스터 간접 주소 지정 방식 : 데이터가 저장된 메모리의 주소를 레지스터에 명시
  
</details>

### 컴파일과정
<details>
<summary></summary>

- 전처리 : 외부 선언 소스코드, 매크로 변환, 컴파일 영역 명시
- 컴파일 : 전처리 완료후에도 여전히 소스코드, 저급업어로 변환
- 어셈블 : 기계어로 변환, 목적코드를 포함하는 목적파일을 만드는 과정
- 링킹 : 각기 다른 목적코드를 병합
  
</details>

### alu
<details>
<summary></summary>

- cpu 내부
- 레지스터를 통해 피연산자를 받아들이고, 재어장치로부터 제어신호를 받는다.
  
</details>

### 제어장치
<details>
<summary></summary>

- cpu내부
  
받는 정보
- 명령어 레지스터 : 해석할 명령어
- 클럭신호
- 플래그 레지스터 : 플래그
- 제어신호

보내는 정보
- 제어신호
  -  cpu내부 : 레지스터, ALU
  -   cpu 외부 : 메모리, 입출력장치
  
</details>

### 레지스터
<details>
<summary></summary>
  
-  프로그램 카운터 : 메모리에서 가져올 명령어의 주소 (메모리에서 읽어 들일 명령어 주소)
-  명령어 레지스터 : 해석할 명령어  (메모리에서 읽은 명령어)
-  메모리 주소 레지스터 : 메모리의 주소
-  메모리 버퍼 레지스터 : 메모리와 주고받을 값 (데이터와 명령어)
-  플래그 레지스터 : 연산결과 또는 CPU상태에 대한 부가적인 정보
-  범용 레지스터 : 자유롭게 사용
-  스택 포인터 : 스택 주소 지정방식에 사용
-  베이스 레지스터 : 변위 주소 지정방식에 사용
  
</details>

### 명령어사이클
<details>
<summary></summary>
  
-  하나의 명령어가 처리되는 주기
-  인출, 실행, 간접, 인터럽트 사이클로 구성
  
</details>

### 인터럽트
<details>
<summary></summary>

- cpu의 정상적인 작업을 방해하는 신호
- 동기 인터럽트 : 예외(프로그래밍 오류와 같은 예상치 못한 상황)
- 비동기 인터럽트 : 하드웨어 인터럽트(입출력장치에 의해 발생)

- 인터럽트 플래그 : 인터럽트를 받아들일 수 있는지 확인 
- 인터럽트 서비스 루틴 : 인터럽트를 처리하는 프로그램
- 인터럽트 백터 : 각각 인터럽트를 구분하기 위한 정보(시작주소 구분)
  
</details>

### 코어
<details>
<summary></summary>
  
- cpu내에서 명령어를 실행하는 부품
  
</details>

### 스레드
<details>
<summary></summary>
  
- 실행 흐름의 단위, 하드웨어적, 소프트웨어적 스레드가 있다
  
</details>

### 명령어파이프라이닝
<details>
<summary></summary>
  
- 동시에 여러 개의 명령어를 겹쳐 실행하는 기법
- 각 단계별 처리시간이 일정, 처리 단계는 균일
  
</details>

### 파이프라인위험
<details>
<summary></summary>

  명령어 파이프라이닝이 성능 향상에 실패하는 경우
  - 데이터 위험 : 명령어 간의 의존성, 이전 명령어의 결과를 기반으로 다음 명령이 수행될 때
  - 제어 위험 : 프로그램 카운터의 갑작스러운 변화
  - 구조 위험 : 프로세서의 자원 부족, 서로다른 명령어가 같은 cpu부품을 쓰려고 할때
  
</details>

### 슈퍼스칼라
<details>
<summary></summary>

- 여러개의 명령어 파이프라인을 두는 기법
  
</details>

### 명령어집합구조
<details>
<summary></summary>

  cpu가 이해할 수 있는 명령어들의 모음

  CISC
  - 복잡한 명령어 집합을 활용
  - 명령어의 형태와 크기가 다양한 가변 길이 명령어
  - 명령어 파이프라이닝 불리

  RISC
  - 명령어의 종류가 적고 짧으며 규격화된 명령어
  - 메모리 접근 최소화(load, store)
  
</details>

### ram
<details>
<summary></summary>

 - 휘발성 저장 장치
 - 실행할 프로그램의 명령어와 데이터가 저장된다.
 - DRAM : 시간이 지나면 저장된 데이터가 점차 사라지는 RAM(주기억장치로 사용)
 - SRAM : 시간이 지나도 저장된 데이터가 사라지지 않는 RAM(캐시 메모리로 사용)
</details>

### 메모리주소
<details>
<summary></summary>

물리 주소
 - 메모리 하드웨어상의 주소

논리 주소
- CPU와 실행 중인 프로그램이 사용하는 주소

MMU가 논리 주소를 물리 주소로 변환한다.

베이스 레지스터

- 프로그램의 가장 작은 물리주소를 저장

한계 레지스터
- 논리 주소의 최대 크기를 저장
  
</details>

### 메모리보호
<details>
<summary></summary>

- CPU가 접근하려는 논리 주소는 한계 레지스터가 저장한 값보다 커서는 안됨
  
</details>

### 캐시
<details>
<summary></summary>

- CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위한 저장 장치
- 캐시 히트, 캐시 미스

  
</details>

### 참조지역성 
<details>
<summary></summary>

- CPU가 메모리에 접근할 때 주된 경향을 바탕으로 만들어진 원리
- 최근에 접근했던 메모리 공간에 다시 접급하려는 경향
- 접근한 메모리 근처를 접근하려는 경향

  
</details>

### 하드디스크 
<details>
<summary></summary>

자기적인 방식으로 데이터 저장
- 플래터 : 데이터가 저장되는 원판
- 트랙 : 플래터를 동심원으로 나누었을 때 그중 하나의 원
- 섹터 : 트랙을 여러 조각으로 나눈 한 조각, 하드디스크의 가장 작은 전송 단위
- 실린더 : 여려 겹의 플래터상에서 같은 트랙이 위치한 곳을 모아 연결
- 접근 시간
  - 탐색시간
  - 회전 지연
  - 전송 시간
  
</details>


### 플래시메모리 
<details>
<summary></summary>

전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치, 덮어쓰기 불가능

- 셀 : 플레시 메모리에서 데이터를 저장하는 가장 작은 단위
- 셀 -> 페이지 -> 블록 -> 다이
- 읽기/쓰기는 페이지 단위로 이루어진다.
- 삭제는 블록 단위로 이루어진다.
- FREE 상태 : 데이터 저장가능
- Vaild 상태 : 이미 유효한 데이터를 저장하고 있는 상태
- Invaild : 유효하지 않은 데이터를 가지고 있는 상태(가비지 컬렉션 사용으로 정리)
  
</details>

### RAID 
<details>
<summary></summary>

- 데이터의 안정성 혹은 높은 성능을 위해 여러 보조기억장치를 마치 하나의 논리적 보조기억장치러럼 사용하는 기술
  
</details>


### 입출력장치의 어려움 
<details>
<summary></summary>

- 다양하여 규격화 하기 어렵다
- 일반적으로 CPU와 메모리의 데이터 전송률은 높지만 입출력장치의 데이터 전송률은 낮다
  
</details>

### 장치컨트롤러
<details>
<summary></summary>

- 입출력 제어기
- 하드웨어
- 입출력장치는 장치 컨트롤러를 통해 정보를 주고받는다.
- 데이터 레지스터, 상태 레지스터, 제어 레지스터
  
</details>

### 장치드라이버
<details>
<summary></summary>

- 장치 컨트롤러의 동작을 감지하고 제어하는 프로그램
- 소프트웨어
  
</details>

### 입출력방식
<details>
<summary></summary>

- 프로그램 입출력 : 프로그램 속 명령어로 입출력장치를 제어하는 방법
- 인터럽트 기반 입출력 : 
- DMA 입출력 : CPU를 거치지 않고 메모리와 입출력장치가 직접적으로 접근, 시스템 버스는 공용자원
  
</details>


